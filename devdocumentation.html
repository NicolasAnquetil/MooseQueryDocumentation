<!DOCTYPE html>
<!--[if IE 8]>
<html lang="en" class="ie8"> <![endif]-->
<!--[if IE 9]>
<html lang="en" class="ie9"> <![endif]-->
<!--[if !IE]><!-->
<html lang="en"> <!--<![endif]-->
<head>
    <title>Moose Query Documentation - API Documentation</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Documentation of Moose Query, the query systeme of the Moose platform.">
    <meta name="author" content="Cyril Ferlicot-Delbecque">

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="assets/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="assets/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="assets/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="assets/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="assets/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="assets/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="assets/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="assets/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="assets/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="assets/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="assets/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="assets/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <!-- End Favicon -->

    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
          rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="assets/js/html5shiv.js"></script>
    <script src="assets/js/respond.min.js"></script>
    <![endif]-->
</head>

<body class="body-pink">
<div class="page-wrapper">
    <!-- ******Header****** -->
    <header id="header" class="header">
        <div class="container">
            <div class="branding">
                <h1 class="logo">
                    <a href="index.html">
                        <span aria-hidden="true" class="icon_documents_alt icon"></span>
                        <span class="text-highlight">Moose</span><span class="text-bold">Query</span>
                    </a>
                </h1>
            </div><!--//branding-->
            <ol class="breadcrumb">
                <li><a href="index.html">Home</a></li>
                <li class="active">Developer Documentation</li>
            </ol>
        </div><!--//container-->
    </header><!--//header-->
    <div class="doc-wrapper">
        <div class="container">
            <div id="doc-header" class="doc-header text-center">
                <h1 class="doc-title"><i class="icon fa fa-code"></i> Developer Documentation</h1>
                <div class="meta"><i class="fa fa-clock-o"></i> Last updated: Mar 12th, 2018</div>
            </div><!--//doc-header-->
            <div class="doc-body">
                <div class="doc-content">
                    <div class="content-inner">
                        <section id="introduction" class="doc-section">
                            <h2 class="section-title">Introduction</h2>
                            <div class="section-block">
                                <p>
                                    MooseQuery is the result of the Inria research team <a href="https://rmod.inria.fr/web/">RMoD</a>. This page documents the internals of MooseQuery. As prerequisites, it supposes the reader has a minimum of knowledge of <var>Fame</var> and <var>Famix</var>. If not, please read the <a href="http://themoosebook.org/book/index.html">Moose documentation</a>, if you wish to understand everything.
                                </p>
                                <p>
                                    This documentation covers:
                                </p>
                                <ul>
                                    <li>How to complete a <var>Famix</var> meta-model to make new entities/relations queryable via MooseQuery</li>
                                    <li>How the containment tree exploration described in the user documentation works</li>
                                    <li>How the navigation queries works</li>
                                    <li>How the scope queries works</li>
                                </ul>
                                <p>
                                    The first section will be useful if you wish to extend/create a meta-model. The three next sections only describe how the query system works. It does not requires any change from the developers of a meta-model.
                                </p>
                            </div>
                        </section>
                        <section id="metamodel" class="doc-section">
                        <h2 class="section-title">Completion of the Meta-model</h2>
                        <div class="section-block">
                            <div class="callout-block callout-info">
                                <div class="icon-holder">
                                    <i class="fa fa-info-circle"></i>
                                </div><!--//icon-holder-->
                                <div class="content">
                                    <p>The content of this section will cover the part of new entities/relations creation specific to MooseQuery. It will not cover how to create new Moose entities. For this, please refer to <a href="http://themoosebook.org/book/index.html">Moose documentation.</a></p>
                                </div><!--//content-->
                            </div>
                            <p>
                                First, the developer of the model has to make his new entities/relations queryable with MooseQuery.
                            </p>
                            <div id="relations" class="section-block">
                                <h3 class="block-title">Relations definitions</h3>
                                <p>
                                    As said in the user documentation, MooseQuery is based on two concepts:
                                </p>
                                <ul>
                                    <li>
                                        Imbrication of entities: which entity contains which entities.
                                    </li>
                                    <li>
                                        Associations between the entities: how the entities interact with each other.
                                    </li>
                                </ul>
                                <figure style="text-align: center">
                                    <img src="assets/images/relationsDev.png" alt="Schema of the two relation types">
                                    <figcaption>Schema of the relation types</figcaption>
                                </figure>
                                <br>
                                <p>
                                    Here, for example, <var>Entity1</var> is the container of <var>Entity2</var> and <var>Entity1</var> is the source of an association whose <var>Entity3</var> is the target.
                                </p>
                                <p>
                                    Moose query needs to know those relations in order to work. To declare them you just need to use three pragma: <var>&lt;container&gt;</var>, <var>&lt;source&gt;</var> and <var>&lt;target&gt;</var>
                                </p>
                                <p>
                                    The container pragma should be put in the contained entity in the method defined to access the container.
                                </p>
                                <div class="callout-block callout-warning">
                                    <div class="icon-holder">
                                        <i class="fa fa-exclamation-triangle"></i>
                                    </div><!--//icon-holder-->
                                    <div class="content">
                                        <p>At the meta-model level, an entity may have several parents. For example, the container of a class can be a package or a method in the case of inner class. In that case, both methods <var>#parentPackage</var> and <var>#container</var> must have the pragma.</p>
                                    </div><!--//content-->
                                </div>
                                <div class="code-block">
                                    <h6>Containment Relation Definition</h6>
                                    <pre><code class="language-smalltalk">
FAMIXAttribute>>parentType
	&lt;MSEProperty: #parentType type: #FAMIXType opposite: #attributes&gt;
	&lt;MSEComment: 'Type declaring the attribute. belongsTo implementation'&gt;
	&lt;container&gt; "<=== Here is the containment relation definition"
	^ parentType
                                    </code></pre>
                                </div><!--//code-block-->
                                <p>
                                    The source and target pragmas must be in the methods relevant of the association.
                                </p>
                                <div class="code-block">
                                    <h6>Association Definition</h6>
                                    <pre><code class="language-smalltalk">
FAMIXAccess>>accessor
	&lt;MSEProperty: #accessor type: #FAMIXBehaviouralEntity opposite: #accesses&gt;
	&lt;MSEComment: 'Behavioural entity making the access to the variable. from-side of the association'&gt;
	&lt;source&gt; "<=== Here is the association's source definition"
	^ accessor

FAMIXAccess>>variable
	&lt;MSEProperty: #variable type: #FAMIXStructuralEntity opposite: #incomingAccesses&gt;
	&lt;MSEComment: 'Variable accessed. to-side of the association'&gt;
	&lt;target&gt; "<=== Here is the association's target definition"
	^ variable
                                    </code></pre>
                                </div><!--//code-block-->
                            </div>
                            <div id="traits" class="section-block">
                                <h3 class="block-title">Traits usage</h3>
                                <p>
                                    Relations definitions (via the pragmas) give to MooseQuery all the requirements for querying the meta-model. Now, the new entities of the model need to have the behaviour, i.e., the methods, to execute the queries. To do so, MooseQuery comes with a set of Traits to use in the new entities.
                                </p>
                                <div class="table-responsive">
                                    <table class="table table-striped">
                                        <thead>
                                            <tr>
                                                <th>Trait</th>
                                                <th>Default users</th>
                                                <th>Description</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <th scope="row"><var>TAssociationMetaLevelDependency</var></th>
                                                <td><var>FAMIXAssociation</var></td>
                                                <td>This trait includes the information about associations needed for the navigation queries. It needs to be used by every association in a meta-model.</td>
                                            </tr>
                                            <tr>
                                                <th scope="row"><var>TEntityMetaLevelDependency</var></th>
                                                <td><var>FAMIXNamedEntity</var></td>
                                                <td>This trait includes the information about entities and adds the behaviour to explore the containment tree and execute scope queries. It needs to be used in every entity's hierarchy in a meta-model.</td>
                                            </tr>
                                            <tr>
                                                <th scope="row"><var>TDependencyQueries</var></th>
                                                <td><var>FAMIXNamedEntity</var></td>
                                                <td>This trait includes the information about entities and adds the behaviour to execute navigation queries. It needs to be used in every entity's hierarchy in a meta-model.</td>
                                            </tr>
                                            <tr>
                                                <th scope="row"><var>TOODependencyQueries</var></th>
                                                <td><var>FAMIXContainerEntity</var></td>
                                                <td>This trait includes the information about object-oriented entities and adds the behaviour to execute navigation queries. It needs to be used in every entity's hierarchy in a meta-model instead of <var>TDependencyQueries</var>.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div><!--//table-responsive-->
                                <p>
                                    All those traits need to be used when implementing a new meta-model. For performance reasons, some more work is needed when using those traits. Some methods exist in two versions. One private with the real behaviour, and the other public that access a class instance variable or, if nil, set it with the result of the private method. Due to the fact that traits are currently stateless in Pharo, all the public methods have to be implemented for your new metaclass using directly the traits and not by inheritance. For example, <var>FAMIXAnnotationInstance</var> does not inherit from <var>FAMIXNamedEntity</var> but can be queried similarly. The same occur for new links using <var>TAssociationMetaLevelDependency</var> without inheriting from <var>FAMIXAssociation</var>. Here is the list of caches to implement:
                                </p>
                                <ul>
                                    <li>
                                        <var>TAssociationMetaLevelDependency class</var>
                                        <ul>
                                            <li><var>#sourceTypes</var></li>
                                            <li><var>#targetTypes</var></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <var>TEntityMetaLevelDependency class</var>
                                        <ul>
                                            <li><var>#allChildrenTypes</var></li>
                                            <li><var>#allParentTypes</var></li>
                                            <li><var>#childrenSelector</var></li>
                                            <li><var>#parentSelector</var></li>
                                            <li><var>#allIncomingAssociationTypes</var></li>
                                            <li><var>#allOutgoingAssociationTypes</var></li>
                                            <li><var>#incomingMSEProperties</var></li>
                                            <li><var>#outgoingMSEPreperties</var></li>
                                        </ul>
                                    </li>
                                </ul>
                                <div class="code-block">
                                    <h6>Example of Cache Implementation</h6>
                                    <pre><code class="language-smalltalk">
"Already defined in MooseQuery:"
TEntityMetaLevelDependency class>>allChildrenTypes
	^ self explicitRequirement

TEntityMetaLevelDependency class>>privateAllChildrenTypes
	^ (self childrenTypes withDeepCollect: #childrenTypes as: Set) asOrderedCollection

"Method to implement:"
FAMIXNamedEntity class>>allChildrenTypes
	^ allChildrenTypes ifNil: [ allChildrenTypes := self privateAllChildrenTypes ]
                                    </code></pre>
                                </div><!--//code-block-->
                                <div class="callout-block callout-info">
                                    <div class="icon-holder">
                                        <i class="fa fa-info-circle"></i>
                                    </div><!--//icon-holder-->
                                    <div class="content">
                                        <p>The model builds caches on classes to speed up queries. It means that during the development of the meta-model it is often required to reset those caches.</p>
                                    </div><!--//content-->
                                </div>
                                <p>
                                    In order to reset the caches you can execute:
                                </p>
                                <div class="code-block">
                                    <pre><code class="language-smalltalk">
MooseModel resetMeta
                                    </code></pre>
                                </div><!--//code-block-->
                                <p>
                                    This method will call <var>#resetMooseQueryCaches</var> on all subclasses of <var>FAMIXEntity</var>. If you add new caches (in a class that directly uses the trait and not through inheritance like <var>FAMIXAnnotationInstance</var>), you need to override in the class side of your entity <var>#resetMooseQueryCaches</var> to reset the added caches.
                                </p>

                                <div class="code-block">
                                    <h6>Example of Cache Reset</h6>
                                    <pre><code class="language-smalltalk">
FAMIXNamedEntity class>>resetMooseQueryCaches
	super resetMooseQueryCaches.
	childrenSelectors := parentSelectors := allChildrenTypes := allParentTypes := outgoingMSEProperties := incomingMSEProperties := incomingAssociationTypes := outgoingAssociationTypes := nil
                                    </code></pre>
                                </div><!--//code-block-->
                            </div>
                        </div>
                        </section>
                        <section id="containment" class="doc-section">
                            <h2 class="section-title">Containment Tree Exploration</h2>
                            <div class="section-block">
                                <div class="callout-block callout-info">
                                    <div class="icon-holder">
                                        <i class="fa fa-info-circle"></i>
                                    </div><!--//icon-holder-->
                                    <div class="content">
                                        <p>This section and the next ones explains how works MooseQuery's queries. From this point, no more action is required from the developer to have working queries on its meta-model.</p>
                                    </div><!--//content-->
                                </div>
                                <p>
                                    Now that we saw how to make entities queryable, this documentation will focus on explaining the internal mechanisms of MooseQuery. The easiest queries are the ones related to the exploration of the containment tree.
                                </p>
                                <p>
                                    MooseQuery allows querying the children/parents of an entity. This behaviour is based on the meta-model of the application. Each Moose entity possesses a meta-description that lists all the properties of the entity. These properties can be obtained with:
                                </p>
                                <div class="code-block">
                                    <h6>Getting the Properties of an Entity</h6>
                                    <pre><code class="language-smalltalk">
MooseEntity class>>allDeclaredProperties
	"All properties described in the meta-model"
	^self mooseDescription allAttributes


FAMIXType allDeclaredProperties. "==> An array of property descriptions (See screenshot bellow)"
                                    </code></pre>
                                </div><!--//code-block-->
                                <figure style="text-align: center">
                                    <img src="assets/images/typesDescriptionsDev.png" alt="Screenshot of `FAMIXType allDeclaredProperties` result." width="85%">
                                    <figcaption>Screenshot of <var>FAMIXType allDeclaredProperties</var> result.</figcaption>
                                </figure>
                                <p>
                                    Each property knows:
                                </p>
                                <ul>
                                    <li>If it is a property enabling to access the contained entities (via the method <var>#isChildrenProperty</var>)</li>
                                    <li>If it is a property defining a parent entity (via the method <var>#isContainer</var>)</li>
                                    <li> The selector returning the property in the entity's API (via the method <var>#implementingSelector</var>)</li>
                                </ul>
                                <p>
                                    So, based on the meta-model and the moose pragma, it is possible for a Famix class to get the selectors to access its parents or children entity using the <var>#parentSelectors</var> and <var>#childrenSelectors</var> methods respectively. Here again a cache mechanism is used.
                                </p>
                                <div class="code-block">
                                    <h6>Getting the parents/children selectors of an entity</h6>
                                    <pre><code class="language-smalltalk">
"Implementation details:"
TEntityMetaLevelDependency class>>privateChildrenSelectors
	^ self allDeclaredProperties select: #isChildrenProperty thenCollect: #implementingSelector

FAMIXNamedEntity class>>childrenSelectors
	^ childrenSelectors ifNil: [ childrenSelectors := self privateChildrenSelectors ]

TEntityMetaLevelDependency class>privateParentSelectors
	^ self allDeclaredProperties select: #isContainer thenCollect: #implementingSelector

FAMIXNamedEntity class>>parentSelectors
	^ parentSelectors ifNil: [ parentSelectors := self privateParentSelectors ]


"Example of use:"
FAMIXType parentSelectors. "=> #(#container #parentPackage)"
FAMIXType childrenSelectors.  "=> #(#annotationInstances #types #definedAnnotationTypes #attributes #functions #methods)"
                                    </code></pre>
                                </div><!--//code-block-->
                                <p>
                                    So, whatever the selector used in the meta-model to access the contained elements of a given entity, it is possible to access them through the children method that dynamically call each selector returned by the <var>#childrenSelectors</var> methods. The same is possible to get the parents of a given entity. Once we retrieved all parents/children selectors it is possible to perform them on an entity to get their results and gather the children/parents of this entity.
                                </p>
                                <div class="code-block">
                                    <h6>Getting the parents/children of an entity</h6>
                                    <pre><code class="language-smalltalk">
"Implementation details:"
TEntityMetaLevelDependency>>children
	| res |
	res := OrderedCollection new.
    "Since some selector can return nil, an entity or a collection of entities, we need to do a nil check and to ensure everything is a collection via #asCollection"
	self childrenSelectors do: [ :accessor | (self perform: accessor) ifNotNil: [ :r | res addAll: r asCollection ] ].
	^ res asSet


TEntityMetaLevelDependency>>parents
	| res |
	res := OrderedCollection new.
    "Since some selector can return nil, an entity or a collection of entities, we need to do a nil check and to ensure everything is a collection via #asCollection"
	self parentSelectors do: [ :accessor | (self perform: accessor) ifNotNil: [ :r | res addAll: r asCollection ] ].
	^ res asSet

"Example from the user documentation:"
package1 children. "=> { package2 . class1 }"
class3 children. "=> { attribute1 . attribute2 }"

package1 parents. "=> { }"
class3 parents. "=> { package2 }"
class4 parents. "=> { package3 . namespace1 }"
                                    </code></pre>
                                </div><!--//code-block-->
                                <p>
                                    No risk to forget a selector, it is dynamically computed from the meta-model.
                                </p>
                                <p>
                                    Similarly, it is possible to get children/parents recursively. Since containment trees can be pretty big, we use an accumulator to avoid creating a lot of collections.
                                </p>
                                <div class="code-block">
                                    <h6>Getting the parents/children of an entity recursively</h6>
                                    <pre><code class="language-smalltalk">
"Implementation details:"
TEntityMetaLevelDependency>>allChildren
	"Returns all the children and sub-children of an entity, i.e my children and those of my children, and those of the children of my children, etc"
	^ self addAllChildrenIn: OrderedCollection new


TEntityMetaLevelDependency>>addAllChildrenIn: aCollection
	aCollection addAll: self children.
	self children do: [ :each | each addAllChildrenIn: aCollection ].
	^ aCollection

"Examples from the user documentation:"
package1 allChildren. "=> { package2 . class1 . class2 . class3 . attribute1 . attribute2 }"
class3 allChildren. "=> { attribute1 . attribute2 }"

class3 allParents. "=> { package2 . package1 }"
attribute1 allParents. "=> { class3 . package2 . package1 }"

                                    </code></pre>
                                </div><!--//code-block-->
                            </div>
                        </section>
                        <section id="navigation" class="doc-section">
                            <h2 class="section-title">Navigation Queries</h2>
                            <div class="section-block">
                                <p>
                                    This section will explain how the navigation queries works.
                                </p>
                                <p>
                                    Navigation queries, as explained in the user documentation, are parametrized by:
                                </p>
                                <ul>
                                    <li>
                                        The direction of the query. Should the receiver be the source or the target of the associations to gather?
                                    </li>
                                    <li>
                                        The scope of the query. Should the query deal with the receiver or deal with the receiver and its children.
                                    </li>
                                    <li>
                                        The association(s) to query. It is possible to query a specific association or all the associations.
                                    </li>
                                </ul>
                                <p>
                                    All those parameters will be explained in this section.
                                </p>
                                <figure style="text-align: center">
                                    <img src="assets/images/navigationDev.png" alt="UML of MooseQuery navigation queries.">
                                    <figcaption>UML of MooseQuery for navigation queries.</figcaption>
                                </figure>
                                <br>
                                <p>
                                    To launch a navigation query, all Moose entities can use an API provided by the trait <var>TDependencyQueries</var>, as explained previously. Those methods all begin in the same way. They send the request to a new instance of <var>MooseQueryCalculator</var> parametrized with the direction of the query.
                                </p>
                                <div id="directions" class="section-block">
                                    <h3 class="block-title">Management of the queries direction</h3>
                                    <p>
                                        This section covers the query direction management.
                                    </p>
                                    <p>
                                        As shown in the UML diagram above, directions are managed via a Design Pattern strategy. A <var>MooseQueryCalculator</var> refers to a strategy that will be either a <var>MooseQueryIncomingDirectionStrategy</var> or a <var>MooseQueryOutgoingDirectionStrategy</var>. The strategies manage everything related to the direction of the query. This includes:
                                    </p>
                                    <ul>
                                        <li>
                                            Obtaining the possible association types for a given entity depending on the direction
                                        </li>
                                        <li>
                                            Obtaining the meta-properties of an entity defining a relation of source/target between the entity and an association
                                        </li>
                                        <li>
                                            Creating a <var>MooseQueryResult</var> for the right direction
                                        </li>
                                    </ul>
                                    <div class="code-block">
                                        <h6>Example of Responsibility Dispatch Between Strategies</h6>
                                        <pre><code class="language-smalltalk">
MooseQueryAbstractDirectionStrategy class>>associationTypesFor: anEntity
	^ self subclassResponsibility


MooseQueryIncomingDirectionStrategy class>>associationTypesFor: anEntity
	^ anEntity incomingAssociationTypes


MooseQueryOutgoingDirectionStrategy class>>associationTypesFor: anEntity
	^ anEntity outgoingAssociationTypes

                                    </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        The selection of the right strategy is done via the symbol <var>#in</var> or <var>#out</var> given by the user. The <var>MooseQueryAbstractDirectionStrategy</var> is able to return the right strategy with this symbol as input.
                                    </p>
                                    <div class="code-block">
                                        <h6>Strategy Selection Mechanism</h6>
                                        <pre><code class="language-smalltalk">
MooseQueryAbstractDirectionStrategy class>>fromSymbol: aSymbol
	"I return the right strategy from a Symbol representing a direction"
	^ self allSubclasses detect: [ :each | each determinatingSymbol = aSymbol ] ifNone: [ self error: 'The symbol passed to the query should be either #in or #out. Here we got ' , aSymbol asString ]


MooseQueryIncomingDirectionStrategy class>>determinatingSymbol
	^ #in


MooseQueryOutgoingDirectionStrategy class>>determinatingSymbol
	^ #out

                                    </code></pre>
                                    </div><!--//code-block-->
                                </div>
                                <div id="local" class="section-block">
                                    <h3 class="block-title">Local queries</h3>
                                    <p>
                                        Now that it is clear how the distinction between the directions of the query is managed, we can see how the navigation queries works. Let's begin with the local queries.
                                    </p>
                                    <p>
                                        Local navigation queries focus only on an entity and do not care about its children. Considering that we want to compute the incoming references of a class. With local queries, we don't care if the class contains inner classes that are referenced or not. It will not gather associations of its children.
                                    </p>
                                    <p>
                                        It is possible to launch a local query via the selector <var>TDependencyQueries>>#queryLocal:with:</var> taking as parameter the direction of the query and the studied association class. This method creates a new <var>MooseQueryCalculator</var> parametrized with the right direction strategy and call <var>MooseQueryCalculator>>#queryLocal:for:</var> with the association class and the receiving entity as parameters.
                                    </p>
                                    <p>
                                        <var>MooseQueryCalculator>>#queryLocal:for:</var> gather the associations and creates a new <var>MooseQueryResult</var> with them via the method #queryResultOn:with:. This method, sent to <var>MooseQueryIncomingDirectionStrategy</var>, return a <var>MooseIncomingQueryResult</var> for the entity. Sent to <var>MooseQueryOutgoingDirectionStrategy</var>, return a <var>MooseOutgoingQueryResult</var>. This is shown in the script bellow.
                                    </p>
                                    <div class="code-block">
                                        <h6>MooseQueryCalculator>>#queryLocal:for:</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>queryLocal: aFAMIXClassAssociation for: anEntity

	^ self strategy queryResultOn: anEntity with: (self queryLocal: aFAMIXClassAssociation for: anEntity in: OrderedCollection new) asSet
                                    </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        To gather the associations we get all the properties returning associations in the right direction from the direction strategy. We then perform all the property names on the entity and select the ones which type match the one as parameter.
                                    </p>
                                    <div class="code-block">
                                        <h6> MooseQueryCalculator>>#queryLocal:for:in:</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>queryLocal: aFAMIXClassAssociation for: anEntity in: aCollection
	"The goal here is to get all the entity's direct associations of the class in parameter. This will not check the associations of the entity's children."

	| properties |
	"Instead of #to:do: we could just use #do: but this implementation is much faster. Maybe sista will remove the needs of the todo later."
	1 to: (properties := self strategy msePropertiesOf: anEntity) size do: [ :ind | (anEntity perform: (properties at: ind) name) ifNotNil: [ :coll | aCollection addAll: (coll asCollection select: [ :each | each isKindOf: aFAMIXClassAssociation ]) ] ].
	^ aCollection
                                    </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        The code of this method is more complex than it should be because of performance reasons. This method can be called a lot in certain cases and it needs to be as efficient as possible. A more readable but less efficient version could be:
                                    </p>
                                    <div class="code-block">
                                        <h6> MooseQueryCalculator>>#queryLocal:for:in:, readable version</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>queryLocal: aFAMIXClassAssociation for: anEntity in: aCollection
	"The goal here is to get all the entity's direct associations of the class in parameter. This will not check the associations of the entity's children."

    (self strategy msePropertiesOf: anEntity) do: [ :property | (anEntity perform: property name) ifNotNil: [ :coll | aCollection addAll: (coll asCollection select: [ :each | each isKindOf: aFAMIXClassAssociation ]) ] ].
	^ aCollection
                                    </code></pre>
                                    </div><!--//code-block-->
                                </div>
                                <div id="global" class="section-block">
                                    <h3 class="block-title">Global queries</h3>
                                    <p>
                                        Local queries are useful, but most of the time users want to get all the associations taking into account the entity itself as source (resp. target) or its contained entities. For example it can be relevant to know all the incoming invocations of class1 (cf. user documentation examples). In this case, a class cannot be the target of an invocation, but what we want to get are all the invocations targeting any methods contained in the class.
                                    </p>
                                    <p>
                                        These queries begin in the same way as local navigation queries. The entity will create a new <var>MooseQueryCalculator</var> parametrized with a direction strategy and return a new <var>MooseQueryResult</var> with the resulting associations. The only part changing is the way of the resulting associations are computed.
                                    </p>
                                    <p>
                                        It will begin by computing the associations of the receiver via the same method as the local navigation queries (<var>MooseQueryCalculator>>queryLocal:for:in:</var>), and then iterate on the children of the entity (which is possible via the methods of the containment tree exploration) to call recursively the query.
                                    </p>
                                    <div class="code-block">
                                        <h6> MooseQueryCalculator>>#query:for:in:</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>query: aFAMIXClassAssociation for: anEntity in: aCollection
	"I know that we could use #do: here, but this algo takes too long on big model, so this is a speed up while the sista vm is not ready for production"

	| selectors |
	self queryLocal: aFAMIXClassAssociation for: anEntity in: aCollection.
	1 to: (selectors := anEntity childrenSelectors) size do: [ :index |
		(anEntity perform: (selectors at: index))
			ifNotNil: [ :children |
				| coll |
				1 to: (coll := children asCollection) size do: [ :i | self query: aFAMIXClassAssociation for: (coll at: i) in: aCollection ] ] ].
	^ aCollection
                                    </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        As for the local queries, the readability of the method is sacrificed for performances. Find below a more readable version.
                                    </p>
                                    <p>
                                        If we compute <var>MooseQueryCalculator query: FAMIXInvocation for: class1</var>, <var>MooseQueryCalculator queryLocal: FAMIXInvocation for: class1</var> returns an empty collection since <var>aFAMIXClass</var> cannot be the target of an invocation. Then for each child of this entity the search is done. Concretely, it is compute only for the methods of class1 or the methods of any other entity contained recursively in class1.
                                    </p>
                                    <div class="code-block">
                                        <h6> MooseQueryCalculator>>#queryLocal:for:in:, readable version</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>query: aFAMIXClassAssociation for: anEntity in: aCollection
	self queryLocal: aFAMIXClassAssociation for: anEntity in: aCollection.
	anEntity childrenSelectors
		do: [ :selector | (anEntity perform: selector) ifNotNil: [ :children | children asCollection do: [ :child | self query: aFAMIXClassAssociation for: child in: aCollection ] ] ].
	^ aCollection
                                    </code></pre>
                                    </div><!--//code-block-->
                                </div>
                                <div id="all" class="section-block">
                                    <h3 class="block-title">Queries on all associations</h3>
                                    <p>
                                        One use of navigation queries is to find the dependencies between entities. To find all the dependencies of an entity it is necessary to compute all associations.
                                    </p>
                                    <p>
                                        MooseQuery allows to directly compute all the associations incoming or outgoing of an entity at once. For performance reasons, the implementation visit the containment tree on time instead of iterating on all associations to execute the queries.
                                    </p>
                                    <p>
                                        The main change in the implementation is done in the local query. Instead of selecting the meta-property where the implementing type is a specific association class, it will gather the result of all properties defining an incoming/outgoing relation with the entity.
                                    </p>
                                    <div class="code-block">
                                        <h6> MooseQueryCalculator>>#queryAllLocalFor:in:</h6>
                                        <pre><code class="language-smalltalk">
 MooseQueryCalculator>>queryAllLocalFor: anEntity in: aCollection
	| properties |
	"Instead of #to:do: we could just use #do: but this implementation is much faster. Maybe sista will remove the needs of the todo later."
	1 to: (properties := self strategy msePropertiesOf: anEntity) size do: [ :ind | (anEntity perform: (properties at: ind) name) ifNotNil: [ :coll | aCollection addAll: coll asCollection ] ].
	^ aCollection
                                    </code></pre>
                                    </div><!--//code-block-->
                                </div>
                            </div>
                        </section>
                        <section id="scope" class="doc-section">
                            <h2 class="section-title">Scope Queries</h2>
                            <div class="section-block">
                                <p>
                                    This section explains how the scope queries works.
                                </p>
                                <p>
                                    A scope query is parametrized by:
                                </p>
                                <ul>
                                    <li>
                                        The direction of the query
                                        <ul>
                                            <li>Up in the containment tree (<var>#atScope:</var>)</li>
                                            <li>Down in the containment tree (<var>#toScope:</var>)</li>
                                            <li>Both up and down in the containment tree (<var>#withScope:</var>)</li>
                                        </ul>
                                    </li>
                                    <li>The Famix entity class defining the scope to query</li>
                                </ul>
                                <p>
                                    A scope query can be applied on:
                                </p>
                                <ul>
                                    <li>A Famix entity</li>
                                    <li>A <var>MooseQueryResult</var> obtained from a navigation query</li>
                                </ul>
                                <div id="entity" class="section-block">
                                    <h3 class="block-title">Query on a Famix entity</h3>
                                    <p>
                                        Queries going up or down in the containment tree for the scope search are usable respectively via the methods <var>TEntityMetaLevelDependency>>#atScope:</var> and <var>#toScope:</var>. For example we can want all the incoming invocations of package P2 (cf. user documentation examples) at class scope. Meaning that we want to compute all the invocations that reach a method recursively contained in P2. But, as a result, we don't want neither the invocations nor the target methods of these invocations. We want the classes containing these methods.
                                    </p>
                                    <p>
                                        These methods begin to create a collection to store the results and call <var>#atScope:in:/#toScope:in:</var> with the newly created collection as a parameter. This is done for performance reasons. Instead of creating multiple collections and use concatenation on them, we create one at the beginning and pass it as a parameter of the query methods.
                                    </p>
                                    <p>
                                        The query then checks if the receiver is of the searched kind. In case it is, the query end and returns the receiver as result. If it is not the case then the query is repeated on the parents/children of the entity depending on the direction in the containment tree of the query.
                                    </p>
                                    <div class="code-block">
                                        <h6> TEntityMetaLevelDependency>>#atScope:in:</h6>
                                        <pre><code class="language-smalltalk">
 TEntityMetaLevelDependency>>atScope: aClassFAMIX in: aCollection
	(self isKindOf: aClassFAMIX)
		ifTrue: [ aCollection add: self ]
		ifFalse: [ "The content of this block could be much more readable with #do: but we do this solution for performances... We need this method to be really really performant."
			| selectors |
			1 to: (selectors := self parentSelectors) size do: [ :ind | (self perform: (selectors at: ind)) atScope: aClassFAMIX in: aCollection ] ].
	^ aCollection
                                        </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        As in the navigation queries, this code could be more readable but it is the way it is for performance reasons. Find the more readable code below.
                                    </p>
                                    <div class="code-block">
                                        <h6> TEntityMetaLevelDependency>>#atScope:in:, readable version</h6>
                                        <pre><code class="language-smalltalk">
 TEntityMetaLevelDependency>>atScope: aClassFAMIX in: aCollection
	(self isKindOf: aClassFAMIX)
		ifTrue: [ aCollection add: self ]
		ifFalse: [ self parentSelectors do: [ :selector | (self perform: selector) atScope: aClassFAMIX in: aCollection ] ].
	^ aCollection
                                        </code></pre>
                                    </div><!--//code-block-->
                                    <p>
                                        In the case of the up and down queries, we will just check if the entity can do up/down scopes and apply them if needed.
                                    </p>
                                    <div class="code-block">
                                        <h6> TEntityMetaLevelDependency>>#withScope:in:</h6>
                                        <pre><code class="language-smalltalk">
 TEntityMetaLevelDependency>>withScope: aClassFAMIX in: aCollection
	self allParentTypes detect: [ :class | aClassFAMIX = class or: [ aClassFAMIX inheritsFrom: class ] ] ifFound: [ self atScope: aClassFAMIX in: aCollection ].
	self allChildrenTypes detect: [ :class | aClassFAMIX = class or: [ aClassFAMIX inheritsFrom: class ] ] ifFound: [ self toScope: aClassFAMIX in: aCollection ].
	^ aCollection
                                        </code></pre>
                                    </div><!--//code-block-->
                                </div>
                                <div id="queryresult" class="section-block">
                                    <h3 class="block-title">Query on a MooseQueryResult</h3>
                                    <p>
                                        Once we understand the scope queries applied to entities, it is easy to understand the scope queries on <var>MooseQueryResult</var>.
                                    </p>
                                    <p>
                                        <var>MooseQueryResults</var> store the associations gathered via a navigation query. Applying a scope query on it gathers the opposites of the first query receiver and apply the scope query on each of them.
                                    </p>
                                    <div class="code-block">
                                        <h6> TDependencyQueryResult>>#atScope:</h6>
                                        <pre><code class="language-smalltalk">
 TDependencyQueryResult>>atScope: aClassFamix
	^ self newObjectResultWith: (self storage inject: OrderedCollection new into: [ :res :dep | (self opposite: dep) atScope: aClassFamix in: res ]) asSet
                                        </code></pre>
                                    </div><!--//code-block-->
                                </div>
                            </div>
                        </section>
                    </div><!--//content-inner-->
                </div><!--//doc-content-->
                <div class="doc-sidebar hidden-xs">
                    <nav id="doc-nav">
                        <ul id="doc-menu" class="nav doc-menu" data-spy="affix">
                            <li><a class="scrollto" href="#introduction">Introduction</a></li>
                            <li>
                                <a class="scrollto" href="#metamodel">Completion of the Meta-model</a>
                                <ul class="nav doc-sub-menu">
                                    <li><a class="scrollto" href="#relations">Relations definitions</a></li>
                                    <li><a class="scrollto" href="#traits">Traits usage</a></li>
                                </ul><!--//nav-->
                            </li>
                            <li><a class="scrollto" href="#containment">Containment Tree Exploration</a></li>
                            <li>
                                <a class="scrollto" href="#navigation">Navigation Queries</a>
                                <ul class="nav doc-sub-menu">
                                    <li><a class="scrollto" href="#directions">Management of the queries direction</a></li>
                                    <li><a class="scrollto" href="#local">Local queries</a></li>
                                    <li><a class="scrollto" href="#global">Global queries</a></li>
                                    <li><a class="scrollto" href="#all">Queries on all associations</a></li>
                                </ul><!--//nav-->
                            </li>
                            <li>
                                <a class="scrollto" href="#scope">Scope Queries</a>
                                <ul class="nav doc-sub-menu">
                                    <li><a class="scrollto" href="#entity">Query on a Famix entity</a></li>
                                    <li><a class="scrollto" href="#queryresult">Query on a MooseQueryResult</a></li>
                                </ul><!--//nav-->
                            </li>
                        </ul><!--//doc-menu-->
                    </nav>
                </div><!--//doc-sidebar-->
            </div><!--//doc-body-->
        </div><!--//container-->
    </div><!--//doc-wrapper-->


</div><!--//page-wrapper-->

<footer id="footer" class="footer text-center">
    <div class="container">
        <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can check out other license options via our website: themes.3rdwavemedia.com */-->
        <small class="copyright">Designed with <i class="fa fa-heart"></i> by <a href="http://themes.3rdwavemedia.com/"
                                                                                 target="_blank">Xiaoying Riley</a> for
            developers
        </small>

    </div><!--//container-->
</footer><!--//footer-->


<!-- Main Javascript -->
<script type="text/javascript" src="assets/plugins/jquery-1.12.3.min.js"></script>
<script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="assets/plugins/prism/prism.js"></script>
<script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>
<script type="text/javascript" src="assets/plugins/jquery-match-height/jquery.matchHeight-min.js"></script>
<script type="text/javascript" src="assets/js/main.js"></script>

</body>
</html> 

